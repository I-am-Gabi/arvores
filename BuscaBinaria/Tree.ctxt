#BlueJ class context
comment0.params=
comment0.target=Tree()
comment0.text=\n\ Construtor\ que\ inicializar\ a\ raiz\ como\ nula\n
comment1.params=node
comment1.target=Tree(Node)
comment1.text=\n\ Construtor\ que\ inicializar\ a\ raiz\ com\ um\ valor\ passado\ por\ par\u00E2metro\n\ \n\ @params\ node\ n\u00F3\ atribuido\ a\ raiz\n
comment10.params=node
comment10.target=int\ calcHeight(Node)
comment10.text=\n\ calcHeight\ -\ m\u00E9todo\ que\ calcula\ a\ altura\ de\ um\ determinado\ n\u00F3\ da\ \u00E1rvore\n\ \n\ @params\ node\ n\u00F3\ que\ ter\u00E1\ a\ altura\ calculada\n\ @return\ a\ \ \ \ caso\ o\ valor\ da\ altura\ da\ subarvore\ a\ esquerda\ seja\ maior\ que\ a\ da\ direita\n\ @return\ b\ \ \ \ caso\ o\ valor\ da\ altura\ da\ subarvore\ a\ direita\ seja\ maior\ que\ a\ da\ esquerda\n
comment11.params=node
comment11.target=int\ calcDepht(Node)
comment11.text=\n\ calcDepht\ -\ m\u00E9todo\ que\ calcula\ e\ retorna\ a\ profundidade\ de\ um\ n\u00F3\n\ \n\ @params\ node\ n\u00F3\ que\ ter\u00E1\ o\ valor\ da\ profundidade\ calculado\n\ @return\ depth\ profundidade\ do\ n\u00F3\ passado\ como\ argumento\n
comment12.params=node\ array
comment12.target=void\ roamPrefix(Node,\ java.util.ArrayList)
comment12.text=\n\ Salva\ os\ valores\ de\ uma\ sub\u00E1rvore\ num\ Array\ em\ ordem\ prefixa\n\ \n\ @param\ node\ n\u00F3\ raiz\ da\ sub\u00E1rvore\n\ @param\ array\ array\ no\ qual\ os\ valores\ da\ sub\u00E1rvore\ ficar\u00E3o\ organizados\ em\ ordem\ prefixa.\n
comment13.params=
comment13.target=Node\ lowerValue()
comment13.text=\n\ lowerValue\ -\ m\u00E9todo\ chamado\ para\ retornar\ o\ menor\ valor\ da\ \u00E1rvore.\n\ O\ menor\ valor\ ser\u00E1\ o\ do\ n\u00F3\ mais\ a\ esquerda\n\ \n\ @return\ node\ n\u00F3\ com\ menor\ valor\ da\ \u00E1rvore\n
comment14.params=node
comment14.target=Node\ lowerValue(Node)
comment14.text=\n\ lowerValue\ -\ retorna\ o\ n\u00F3\ com\ menor\ valor\ da\ sub\u00E1rvore\ da\ qual\ node\ \u00E9\ a\ raiz\ (n\u00F3\ mais\ \u00E0\ esquerda)\n\ \n\ @param\ node\ raiz\ da\ sub\u00E1rvore\n\ @return\ retorna\ refer\u00EAncia\ ao\ n\u00F3\ com\ menor\ chave\ da\ sub\u00E1rvore\n
comment15.params=
comment15.target=Node\ greaterValue()
comment15.text=\n\ greaterValue\ -\ m\u00E9todo\ chamado\ para\ retornar\ o\ maior\ valor\ da\ \u00E1rvore.\n\ No\ nosso\ caso,\ o\ maior\ valor\ ser\u00E1\ a\ informa\u00E7\u00E3o\ que\ estiver\ no\ n\u00F3\ mais\ a\ direita.\n\ \n\ @return\ node\ n\u00F3s\ com\ maior\ valor\ da\ \u00E1rvore\n
comment16.params=node
comment16.target=Node\ greaterValue(Node)
comment16.text=\n\ greaterValue\ -\ retorna\ o\ n\u00F3\ com\ maior\ valor\ da\ sub\u00E1rvore\ da\ qual\ node\ \u00E9\ a\ raiz\ (n\u00F3\ mais\ \u00E0\ direita)\n\ \n\ @param\ node\ raiz\ da\ sub\u00E1rvore\n\ @return\ retorna\ refer\u00EAncia\ ao\ n\u00F3\ com\ maior\ chave\ da\ sub\u00E1rvore\n
comment17.params=
comment17.target=void\ printPrefix()
comment17.text=\n\ printPrefix\ -\ m\u00E9todo\ chamado\ para\ imprimir\ os\ valores\ da\ \u00E1rvore\ \n\ seguindo\ um\ caminhamento\ prefixado\n
comment18.params=node
comment18.target=void\ printPrefix(Node)
comment18.text=\n\ printPrefix\ -\ m\u00E9todo\ que\ imprimir\u00E1\ efetivamente\ os\ elementos\ da\ \u00E1rvore\ \n\ seguindo\ um\ caminhamento\ prefixado\n\ \n\ @params\ node\ n\u00F3\ que\ marcar\u00E1\ o\ in\u00EDcio\ da\ impress\u00E3o\ da\ \u00E1rvore\n
comment19.params=
comment19.target=void\ printPosfix()
comment19.text=\n\ printPosfix\ -\ m\u00E9todo\ chamado\ para\ imprimir\ os\ elementos\ da\ \u00E1rvore\ \n\ seguindo\ um\ caminhamento\ p\u00F3s-fixado\n
comment2.params=key
comment2.target=Node\ add(int)
comment2.text=\n\ add\ -\ m\u00E9todo\ chamado\ para\ adicionar\ um\ n\u00F3\ na\ \u00E1rvore\n\ \n\ @params\ key\ O\ valor\ da\ chave\ do\ n\u00F3\ que\ ser\u00E1\ adicionado\ em\ na\ \u00E1rvore\n\ @return\ Retorna\ o\ n\u00F3\ que\ foi\ adicionado\ ou\ null\ caso\ a\ chave\ j\u00E1\ exista\ na\ \u00E1rvore\n
comment20.params=node
comment20.target=void\ printPosfix(Node)
comment20.text=\n\ printPosfix\ -\ m\u00E9todo\ que\ efetivamente\ vai\ imprimir\ os\ elementos\ da\ \u00E1rvore\ \n\ seguindo\ um\ caminhamento\ p\u00F3s-fixado\n\ \n\ @params\ node\ n\u00F3\ que\ marca\ o\ in\u00EDcio\ da\ impress\u00E3o\ dos\ n\u00F3s\ da\ \u00E1rvore\n
comment21.params=
comment21.target=Node\ getRoot()
comment21.text=\n\ getRoot()\ -\ M\u00E9todo\ que\ retorna\ o\ n\u00F3\ raiz\ da\ \u00E1rvore\n\ \n\ @return\ root\ n\u00F3\ raiz\ da\ arvore\ \n
comment22.params=rem\ newMin
comment22.target=void\ updateMin(Node,\ Node)
comment22.text=\n\ updateMin\ -\ Atualiza\ a\ refer\u00EAncia\ da\ chave\ m\u00EDnima\ de\ uma\ sub\u00E1rvore\ em\ n\u00F3s\ ancestrais\ antes\ de\ remover\ um\ n\u00F3\n\ \n\ @param\ rem\ N\u00F3\ que\ dever\u00E1\ ser\ removido\ ap\u00F3s\ a\ execu\u00E7\u00E3o\ do\ m\u00E9todo\ em\ chamada\ externa\n\ @param\ newMin\ N\u00F3\ que\ armazena\ o\ novo\ candidato\ a\ menor\ da\ \u00E1rvore\n
comment23.params=rem\ newMax
comment23.target=void\ updateMax(Node,\ Node)
comment23.text=\n\ updateMax\ -\ Atualiza\ a\ refer\u00EAncia\ da\ chave\ m\u00E1xima\ de\ uma\ sub\u00E1rvore\ em\ n\u00F3s\ ancestrais\ antes\ de\ remover\ um\ n\u00F3\n\ \n\ @param\ rem\ N\u00F3\ que\ dever\u00E1\ ser\ removido\ ap\u00F3s\ a\ execu\u00E7\u00E3o\ do\ m\u00E9todo\ em\ chamada\ externa\n\ @param\ newMax\ N\u00F3\ que\ armazena\ o\ novo\ candidato\ a\ maior\ da\ \u00E1rvore\n
comment3.params=node\ key
comment3.target=Node\ add(Node,\ int)
comment3.text=\n\ add\ -\ m\u00E9todo\ que\ adiciona\ efetivamente\ um\ valor\ em\ um\ determinado\ n\u00F3.\ Ele\ verifica\ pelo\ valor\ da\ chave\ (key,\ enviado\ por\ par\u00E2metro)\ se\ a\ \n\ inst\u00E2ncia\ o\ novo\ n\u00F3\ deve\ ser\ o\ filho\ da\ esquerda\ ou\ a\ direita\ do\ n\u00F3.\n\ \n\ @params\ node\ n\u00F3\ que\ ter\u00E1\ os\ filhos\ verificados\ para\ um\ deles\ ser\ preenchido\n\ @params\ key\ valor\ da\ chave\ que\ ser\u00E1\ atribuida\ ao\ campo\ key\ do\ n\u00F3\ adicionado\n\ @return\ Retorna\ o\ n\u00F3\ que\ foi\ adicionado\n
comment4.params=to
comment4.target=void\ remove(Node)
comment4.text=\n\ remove\ -\ m\u00E9todo\ que\ ir\u00E1\ remover\ um\ n\u00F3\ da\ \u00E1rvore.\n\ Tr\u00EAs\ casos\ podem\ acontecer.\n\ 1)\ Caso\ o\ n\u00F3\ seja\ uma\ folha,\ e\ n\u00E3o\ possua\ sub-\u00E1rvores\n\ \ -\ nesse\ caso,\ \u00E9\ s\u00F3\ setar\ como\ nulo\ o\ campo\ que\ "aponta"\ para\ o\ n\u00F3\ removido\n\ 2)\ Caso\ o\ n\u00F3\ possua\ apenas\ uma\ sub-\u00E1rvore,\ a\ esquerda\ ou\ a\ direita\n\ \ -\ nesse\ caso,\ o\ valor\ que\ faz\ refer\u00EAncia\ ao\ n\u00F3\ removido\ passa\ a\ fazer\ refer\u00EAncia\ \n\ \ a\ sub-\u00E1rvore\ que\ existia\ ligado\ ao\ este\ n\u00F3\n\ 3)\ Caso\ o\ n\u00F3\ possua\ duas\ sub-\u00E1rvores\n\ \ -\ nessa\ situa\u00E7\u00E3o,\ pegamos\ um\ valor\ menor,\ abaixo\ desse\ n\u00F3\ que\ quero\ remover\ (no\ caso,\ pegarmos\ um\ que\ seja\ uma\ folha.\ \n\ \ removemos\ esse\ n\u00F3\ folha\ que\ estava\ no\ final\ e\ substituimos\ o\ n\u00F3\ que\ quer\u00EDamos\ remover\ inicialmente,\ por\ ele.\n
comment5.params=key
comment5.target=Node\ searchBreadth(int)
comment5.text=\n\ searchBreadth\ -\ buscar\ um\ elemento\ utilizando\ a\ estrat\u00E9gia\ de\ busca\ em\ largura.\n\ Inicialmente\ ele\ cria\ dois\ ArrayLists\ para\ armazenar\ a\ sub\u00E1rvore\ a\ esquerda\ \n\ e\ a\ direita.\ E\ ent\u00E3o\ pesquisa\ o\ valor\ 'key'\ em\ ambos\ os\ arrays.\n\ A\ forma\ como\ esses\ arrays\ s\u00E3o\ criados\ e\ acessados,\ faz\ com\ que\ os\ valores\n\ sejam\ visitados\ pela\ t\u00E9cnica\ da\ largura\n\ \n\ @params\ key\ inteiro\ que\ armazena\ o\ valor\ da\ chave\ a\ ser\ pesquisado\ \n\ @return\ node\ n\u00F3\ com\ o\ valor\ que\ est\u00E1\ sendo\ buscado,\ caso\ n\u00E3o\ encontre\ retorna\ null\n
comment6.params=key
comment6.target=Node\ searchDepth(int)
comment6.text=\n\ searchDepth\ -\ buscar\ um\ elemento\ utilizando\ a\ estrat\u00E9gia\ de\ busca\ em\ profundidade\n\ \n\ @params\ key\ valor\ da\ chave\ do\ n\u00F3\ que\ est\u00E1\ sendo\ pesquisada\n\ @return\ node\ n\u00F3\ com\ o\ valor\ que\ est\u00E1\ sendo\ buscado.\ Retornar\u00E1\ null\ caso\ valor\ n\u00E3o\ seja\ encontrado\n
comment7.params=node\ key
comment7.target=Node\ searchDepth(Node,\ int)
comment7.text=\n\ searchDepth\ -\ buscar\ um\ elemento\ utilizando\ a\ estrat\u00E9gia\ de\ busca\ em\ profundidade\n\ \n\ @params\ node\ n\u00F3\ que\ marcar\u00E1\ o\ ponto\ a\ partir\ do\ qual\ a\ busca\ acontecer\u00E1\ na\ \u00E1rvore\n\ @params\ key\ valor\ da\ chave\ que\ est\u00E1\ sendo\ pesquisada\n\ @return\ node\ n\u00F3\ com\ o\ valor\ que\ est\u00E1\ sendo\ buscado.\ Retornar\u00E1\ null\ caso\ valor\ n\u00E3o\ seja\ encontrado\n
comment8.params=key
comment8.target=boolean\ hasNode(int)
comment8.text=\n\ hasNode\ -\ m\u00E9todo\ chamado\ quando\ queremos\ verificar\ se\ h\u00E1\ registro\ com\ a\ chave\ passada\ por\ par\u00E2metro\n\ \n\ @params\ key\ valor\ da\ chave\ que\ ser\u00E1\ usado\ para\ verificar\ a\ exist\u00EAncia\ de\ um\ registro\ semelhante\n\ @return\ True\ caso\ tenha\ encontrado,\ ou\ False\ caso\ contr\u00E1rio\n
comment9.params=node\ key
comment9.target=boolean\ seachKey(Node,\ int)
numComments=24
